package internal

import (
	"fmt"
	"regexp"
	"strings"
)

const (
	// MaxLinesPerFile is the threshold for considering a file change "large"
	MaxLinesPerFile = 1000
	// MaxTotalTokens is our target after filtering
	MaxTotalTokens = 6000 // Leave some buffer under the 8000 limit
	// SummaryLines is how many lines to show from large files
	SummaryLines = 50
)

// FileChange represents changes to a single file
type FileChange struct {
	Path         string
	IsNew        bool
	IsDeleted    bool
	LinesAdded   int
	LinesRemoved int
	Content      string
	IsGenerated  bool
}

// DiffSummary contains the filtered and summarized diff
type DiffSummary struct {
	Files        []FileChange
	TotalLines   int
	FilteredDiff string
}

// FilterDiff processes a git diff and filters out or summarizes large/generated files
func FilterDiff(diff string) (*DiffSummary, error) {
	files, err := parseDiffByFile(diff)
	if err != nil {
		return nil, fmt.Errorf("failed to parse diff: %w", err)
	}

	// Mark auto-generated files
	for i := range files {
		files[i].IsGenerated = isAutoGenerated(files[i].Path, files[i].Content)
	}

	// Filter and summarize
	summary := &DiffSummary{Files: files}
	summary.FilteredDiff = buildFilteredDiff(files)
	
	return summary, nil
}

// parseDiffByFile splits a git diff into per-file changes
func parseDiffByFile(diff string) ([]FileChange, error) {
	var files []FileChange
	
	// Split diff by file headers (lines starting with "diff --git")
	diffPattern := regexp.MustCompile(`(?m)^diff --git a/(.+?) b/(.+?)$`)
	fileStartIndices := diffPattern.FindAllStringIndex(diff, -1)
	matches := diffPattern.FindAllStringSubmatch(diff, -1)
	
	if len(fileStartIndices) == 0 {
		// No file headers found, treat as single change
		return []FileChange{{
			Path:    "unknown",
			Content: diff,
		}}, nil
	}
	
	for i, match := range matches {
		start := fileStartIndices[i][0]
		var end int
		if i+1 < len(fileStartIndices) {
			end = fileStartIndices[i+1][0]
		} else {
			end = len(diff)
		}
		
		filePath := match[2] // Use the "b/" path (destination)
		fileContent := diff[start:end]
		
		file := FileChange{
			Path:    filePath,
			Content: fileContent,
		}
		
		// Analyze the file change
		analyzeFileChange(&file)
		
		files = append(files, file)
	}
	
	return files, nil
}

// analyzeFileChange extracts metadata about a file change
func analyzeFileChange(file *FileChange) {
	lines := strings.Split(file.Content, "\n")
	
	for _, line := range lines {
		if strings.HasPrefix(line, "new file mode") {
			file.IsNew = true
		} else if strings.HasPrefix(line, "deleted file mode") {
			file.IsDeleted = true
		} else if strings.HasPrefix(line, "+") && !strings.HasPrefix(line, "+++") {
			file.LinesAdded++
		} else if strings.HasPrefix(line, "-") && !strings.HasPrefix(line, "---") {
			file.LinesRemoved++
		}
	}
}

// isAutoGenerated detects if a file is likely auto-generated
func isAutoGenerated(path, content string) bool {
	// Check file extension patterns
	autoGenExts := []string{
		".min.js", ".min.css", ".bundle.js", ".bundle.css",
		".generated.go", ".pb.go", ".gen.go",
		".d.ts", ".map",
	}
	
	for _, genExt := range autoGenExts {
		if strings.HasSuffix(strings.ToLower(path), genExt) {
			return true
		}
	}
	
	// Check path patterns
	autoGenPaths := []string{
		"node_modules/", "vendor/", "dist/", "build/", "target/",
		"generated/", "gen/", "__pycache__/", ".next/",
		"coverage/", "tmp/", "temp/",
	}
	
	for _, genPath := range autoGenPaths {
		if strings.Contains(strings.ToLower(path), genPath) {
			return true
		}
	}
	
	// Check content patterns
	autoGenMarkers := []string{
		"// Code generated", "/* Code generated", "# Code generated",
		"// This file is automatically generated", "/* This file is automatically generated",
		"// AUTO-GENERATED", "/* AUTO-GENERATED", "# AUTO-GENERATED",
		"@generated", "autogenerated on", "DO NOT EDIT",
	}
	
	lowerContent := strings.ToLower(content)
	for _, marker := range autoGenMarkers {
		if strings.Contains(lowerContent, strings.ToLower(marker)) {
			return true
		}
	}
	
	return false
}

// buildFilteredDiff creates a filtered version of the diff
func buildFilteredDiff(files []FileChange) string {
	var result strings.Builder
	currentTokens := 0
	
	// Sort files by priority (non-generated first, smaller changes first)
	prioritizedFiles := prioritizeFiles(files)
	
	for _, file := range prioritizedFiles {
		fileTokens := estimateTokens(file.Content)
		
		if file.IsGenerated {
			// For generated files, add a summary instead of full content
			summary := fmt.Sprintf("diff --git a/%s b/%s\n", file.Path, file.Path)
			if file.IsNew {
				summary += "new file mode 100644\n"
			} else if file.IsDeleted {
				summary += "deleted file mode 100644\n"
			}
			summary += fmt.Sprintf("# Auto-generated file: +%d -%d lines (content truncated)\n", 
				file.LinesAdded, file.LinesRemoved)
			
			result.WriteString(summary)
			currentTokens += estimateTokens(summary)
		} else if file.LinesAdded+file.LinesRemoved > MaxLinesPerFile {
			// For large non-generated files, show truncated version
			truncated := truncateFileContent(file)
			result.WriteString(truncated)
			currentTokens += estimateTokens(truncated)
		} else if currentTokens+fileTokens < MaxTotalTokens {
			// Include full content for normal files
			result.WriteString(file.Content)
			currentTokens += fileTokens
		} else {
			// Token limit reached, add summary for remaining files
			summary := fmt.Sprintf("# Additional file: %s (+%d -%d lines, truncated due to size)\n",
				file.Path, file.LinesAdded, file.LinesRemoved)
			result.WriteString(summary)
		}
		
		result.WriteString("\n")
		
		// Stop if we're approaching token limit
		if currentTokens > MaxTotalTokens {
			break
		}
	}
	
	return result.String()
}

// prioritizeFiles sorts files by importance for PR description
func prioritizeFiles(files []FileChange) []FileChange {
	// Create a copy to avoid modifying the original
	sorted := make([]FileChange, len(files))
	copy(sorted, files)
	
	// Simple priority: non-generated first, then by size
	for i := 0; i < len(sorted)-1; i++ {
		for j := i + 1; j < len(sorted); j++ {
			if shouldSwap(sorted[i], sorted[j]) {
				sorted[i], sorted[j] = sorted[j], sorted[i]
			}
		}
	}
	
	return sorted
}

// shouldSwap determines if two files should be swapped in priority order
func shouldSwap(a, b FileChange) bool {
	// Non-generated files have higher priority
	if !a.IsGenerated && b.IsGenerated {
		return false
	}
	if a.IsGenerated && !b.IsGenerated {
		return true
	}
	
	// Smaller files have higher priority
	aSize := a.LinesAdded + a.LinesRemoved
	bSize := b.LinesAdded + b.LinesRemoved
	return aSize > bSize
}

// truncateFileContent shows a summary of a large file change
func truncateFileContent(file FileChange) string {
	lines := strings.Split(file.Content, "\n")
	
	if len(lines) <= SummaryLines*2 {
		return file.Content
	}
	
	var result strings.Builder
	
	// Show file header
	headerLines := 0
	for _, line := range lines {
		result.WriteString(line + "\n")
		headerLines++
		
		if strings.HasPrefix(line, "@@") || headerLines >= 10 {
			break
		}
	}
	
	// Show first few changes
	changeLines := 0
	for lineIdx := headerLines; lineIdx < len(lines) && changeLines < SummaryLines; lineIdx++ {
		line := lines[lineIdx]
		if strings.HasPrefix(line, "+") || strings.HasPrefix(line, "-") {
			result.WriteString(line + "\n")
			changeLines++
		} else if changeLines > 0 {
			result.WriteString(line + "\n")
		}
	}
	
	// Add truncation notice
	result.WriteString(fmt.Sprintf("\n# ... (truncated: %d total lines changed) ...\n", 
		file.LinesAdded+file.LinesRemoved))
	
	return result.String()
}